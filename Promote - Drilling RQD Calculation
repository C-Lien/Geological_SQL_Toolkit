DROP TABLE IF EXISTS #TempRMUTable;
DROP TABLE IF EXISTS #TempAggregationTable;
DROP TABLE IF EXISTS #TempDefectAggregation1;
DROP TABLE IF EXISTS #TempDefectAggregation2;
DROP TABLE IF EXISTS #TempDefectAggregation3;
DROP TABLE IF EXISTS #TempDefectAggregation4;
DROP TABLE IF EXISTS #TempDefectAggregation5;
DROP TABLE IF EXISTS #TempDefectAggregation6;
--DROP TABLE IF EXISTS #TempDefectAggregation7;

WITH cte AS (
    SELECT
        d.SITE_ID,
        d.PROJECT,
        d.RUN_NO,
        d.FROM_DEPTH AS DRILLER_FROM,
        d.TO_DEPTH AS DRILLER_TO,
		d.TO_DEPTH - d.FROM_DEPTH AS DRILLER_THICKNESS,
		d.GEO_TO_DEPTH - d.RECOVERED_LEN AS GEO_FROM_DEPTH,
		d.GEO_TO_DEPTH,
		d.RECOVERED_LEN AS GEO_THICKNESS,
        CASE
            WHEN r.TO_DEPTH < (d.GEO_TO_DEPTH - d.RECOVERED_LEN) OR r.FROM_DEPTH > d.GEO_TO_DEPTH THEN NULL
            ELSE r.RMU_TYPE
        END as RMU_TYPE,
        CASE
            WHEN r.FROM_DEPTH < (d.GEO_TO_DEPTH - d.RECOVERED_LEN) AND r.TO_DEPTH > (d.GEO_TO_DEPTH - d.RECOVERED_LEN) THEN (d.GEO_TO_DEPTH - d.RECOVERED_LEN)
            WHEN r.FROM_DEPTH >= (d.GEO_TO_DEPTH - d.RECOVERED_LEN) AND r.TO_DEPTH <= d.GEO_TO_DEPTH THEN r.FROM_DEPTH
            WHEN r.FROM_DEPTH < d.GEO_TO_DEPTH AND r.TO_DEPTH > d.GEO_TO_DEPTH THEN r.FROM_DEPTH
            ELSE NULL
        END AS RMU_FROM,
        CASE
            WHEN r.FROM_DEPTH < (d.GEO_TO_DEPTH - d.RECOVERED_LEN) AND r.TO_DEPTH > (d.GEO_TO_DEPTH - d.RECOVERED_LEN) THEN r.TO_DEPTH
            WHEN r.FROM_DEPTH >= (d.GEO_TO_DEPTH - d.RECOVERED_LEN) AND r.TO_DEPTH <= d.GEO_TO_DEPTH THEN r.TO_DEPTH
            WHEN r.FROM_DEPTH < d.GEO_TO_DEPTH AND r.TO_DEPTH > d.GEO_TO_DEPTH THEN d.GEO_TO_DEPTH
            ELSE NULL
        END AS RMU_TO 
    FROM GB_CS_DRILLING as d 
	--FROM GB_RAW_DRILLING as d -- RAW data
    --LEFT JOIN GB_CS_RMU_DEFECTS as r  
	LEFT JOIN GB_RAW_RMU_DEFECTS as r  -- RAW data
        ON d.SITE_ID = r.SITE_ID AND d.PROJECT = r.PROJECT 
    WHERE 
        (r.TO_DEPTH >= (d.GEO_TO_DEPTH - d.RECOVERED_LEN) OR r.FROM_DEPTH <= d.GEO_TO_DEPTH)
)
SELECT *
INTO #TempRMUTable
FROM cte
WHERE 

PROJECT = 'UserProject'

AND RUN_NO IS NOT NULL
AND RUN_NO > 0
AND RMU_TYPE IS NOT NULL
AND RMU_FROM IS NOT NULL
AND RMU_TO IS NOT NULL

--AND SITE_ID = 'UserSiteID' -- Site ID

AND GEO_TO_DEPTH IS NOT NULL
AND GEO_THICKNESS IS NOT NULL
ORDER BY RUN_NO, RMU_FROM;

WITH cte1 AS (
    SELECT *,
        CASE WHEN RMU_TYPE = LAG(RMU_TYPE) OVER (PARTITION BY PROJECT, SITE_ID, RUN_NO ORDER BY RMU_FROM)
            THEN 0 ELSE 1 END as lag_flag
    FROM #TempRMUTable
),
cte2 AS (
    SELECT *,
        SUM(lag_flag) OVER (PARTITION BY PROJECT, SITE_ID, RUN_NO ORDER BY RMU_FROM) AS group_id
    FROM cte1
)
SELECT 
    SITE_ID, 
    PROJECT, 
    RUN_NO, 
    MIN(DRILLER_FROM) AS DRILLER_FROM,
    MAX(DRILLER_TO) AS DRILLER_TO,
	MAX(DRILLER_THICKNESS) AS DRILLER_THICKNESS,
	MIN(GEO_FROM_DEPTH) AS GEO_FROM_DEPTH,
	MAX(GEO_TO_DEPTH) AS GEO_TO_DEPTH,
	MAX(GEO_THICKNESS) AS GEO_THICKNESS,
    RMU_TYPE,
    MIN(RMU_FROM) AS RMU_FROM,
    MAX(RMU_TO) AS RMU_TO
INTO #TempAggregationTable
FROM cte2
GROUP BY SITE_ID, PROJECT, RUN_NO, RMU_TYPE, group_id
ORDER BY RUN_NO, RMU_FROM;

SELECT
    t.PROJECT,
    t.SITE_ID,
    t.RUN_NO, 
    t.DRILLER_FROM,
    t.DRILLER_TO,
    t.DRILLER_THICKNESS,
    t.GEO_FROM_DEPTH,
    t.GEO_TO_DEPTH,
    t.GEO_THICKNESS,
    t.RMU_TYPE,
    t.RMU_FROM,
    t.RMU_TO,
	CASE 
		WHEN t.RMU_TYPE IN ('N', 'O', 'L', 'U') THEN t.RMU_TYPE
		WHEN r.DEFECT_DEPTH BETWEEN t.GEO_FROM_DEPTH AND t.GEO_TO_DEPTH 
			AND r.DEFECT_TYPE NOT IN ('DB', 'CE', 'XB', 'FO', 'DZ') 
			--AND r.DEFECT_INTACT IS NULL -- CHECK DEFECT_INTACT BOOL
			THEN r.DEFECT_TYPE
		ELSE NULL
	END AS DEFECT_TYPE,
    CASE 
		WHEN t.RMU_TYPE IN ('N', 'O', 'L', 'U') THEN t.RMU_TO
        WHEN r.DEFECT_DEPTH BETWEEN t.GEO_FROM_DEPTH AND t.GEO_TO_DEPTH 
            AND r.DEFECT_TYPE NOT IN ('DB', 'CE', 'XB', 'FO', 'DZ') 
			AND r.DEFECT_INTACT IS NULL -- CHECK DEFECT_INTACT BOOL
			THEN r.DEFECT_DEPTH
        ELSE NULL
    END AS DEFECT_DEPTH,
	CASE
	    WHEN r.DEFECT_TYPE IN ('SH', 'BZ') THEN r.DEFECT_LENGTH
        WHEN r.DEFECT_DEPTH BETWEEN t.GEO_FROM_DEPTH AND t.GEO_TO_DEPTH 
             AND r.DEFECT_TYPE NOT IN ('DB', 'CE', 'XB', 'FO', 'DZ') 
			 AND r.DEFECT_INTACT IS NULL -- CHECK DEFECT_INTACT BOOL
			 AND r.PREP_WIDTH IS NOT NULL
			 AND r.PREP_WIDTH > 1
			 THEN r.PREP_WIDTH -- NEW COLUMN - IDENTIFY DEFECT THICKNESS WHERE PRESENT
        ELSE NULL
    END AS DEFECT_WIDTH,
	CASE
        WHEN t.RMU_TYPE IN ('N', 'O', 'L', 'U') THEN t.RMU_FROM
		WHEN r.DEFECT_TYPE IN ('SH', 'BZ') THEN ROUND(r.DEFECT_DEPTH - (r.DEFECT_LENGTH / 1000) / 2, 3)
		WHEN r.DEFECT_DEPTH BETWEEN t.GEO_FROM_DEPTH AND t.GEO_TO_DEPTH 
             AND r.DEFECT_TYPE NOT IN ('DB', 'CE', 'XB', 'FO', 'DZ') 
			 AND r.DEFECT_INTACT IS NULL -- CHECK DEFECT_INTACT BOOL
			 AND r.PREP_WIDTH IS NOT NULL
			 AND r.PREP_WIDTH > 1
			 THEN  ROUND(r.DEFECT_DEPTH - (r.PREP_WIDTH / 1000) / 2, 3) -- NEW COLUMN - IDENTIFY DEFECT FROM WHERE PRESENT
        ELSE NULL
    END AS DEFECT_FROM,
	CASE
        WHEN t.RMU_TYPE IN ('N', 'O', 'L', 'U') THEN t.RMU_TO
		WHEN r.DEFECT_TYPE IN ('SH', 'BZ') THEN ROUND(r.DEFECT_DEPTH + (r.DEFECT_LENGTH / 1000) / 2, 3)
		WHEN r.DEFECT_DEPTH BETWEEN t.GEO_FROM_DEPTH AND t.GEO_TO_DEPTH 
             AND r.DEFECT_TYPE NOT IN ('DB', 'CE', 'XB', 'FO', 'DZ') 
			 AND r.DEFECT_INTACT IS NULL -- CHECK DEFECT_INTACT BOOL
			 AND r.PREP_WIDTH IS NOT NULL
			 AND r.PREP_WIDTH > 1
			 THEN ROUND(r.DEFECT_DEPTH + (r.PREP_WIDTH / 1000) / 2, 3) -- NEW COLUMN - IDENTIFY DEFECT TO WHERE PRESENT
        ELSE NULL
    END AS DEFECT_TO
INTO #TempDefectAggregation1
FROM #TempAggregationTable AS t
--LEFT JOIN GB_CS_RMU_DEFECTS AS r -- PRODUCTION table
LEFT JOIN GB_RAW_RMU_DEFECTS AS r -- RAW table
  ON t.PROJECT = r.PROJECT AND t.SITE_ID = r.SITE_ID AND r.DEFECT_DEPTH BETWEEN t.RMU_FROM AND t.RMU_TO
WHERE 
  t.RUN_NO IS NOT NULL
  AND t.RUN_NO > 0
  --AND t.RUN_NO = 3
ORDER BY t.RMU_FROM, r.DEFECT_DEPTH;

WITH cte AS (
  SELECT *, ROW_NUMBER() OVER (PARTITION BY PROJECT, SITE_ID, RUN_NO ORDER BY RMU_TO DESC) as rn
  FROM #TempDefectAggregation1
)
SELECT * 
INTO #TempDefectAggregation2
FROM (
  SELECT 
    PROJECT,
    SITE_ID,
    RUN_NO,
    DRILLER_FROM,
    DRILLER_TO,
    DRILLER_THICKNESS,
    GEO_FROM_DEPTH,
    GEO_TO_DEPTH,
    GEO_THICKNESS,
    RMU_TYPE,
    RMU_FROM,
    RMU_TO,
    DEFECT_TYPE,
    DEFECT_DEPTH,
	DEFECT_FROM,
	DEFECT_TO
  FROM cte
  UNION ALL
  SELECT 
    PROJECT,
    SITE_ID, 
    RUN_NO,
    DRILLER_FROM, 
    DRILLER_TO,
    DRILLER_THICKNESS,
    GEO_FROM_DEPTH,
    GEO_TO_DEPTH,
    GEO_THICKNESS,
    'Z' AS RMU_TYPE,
    RMU_FROM AS RMU_FROM,
    RMU_TO AS RMU_TO, 
    'Z' AS DEFECT_TYPE, 
    RMU_TO AS DEFECT_DEPTH,
	DEFECT_FROM,
	DEFECT_TO
  FROM cte
  WHERE rn = 1
) foo
--WHERE DEFECT_DEPTH IS NOT NULL
--WHERE RUN_NO = 3
ORDER BY RUN_NO, DEFECT_DEPTH;

WITH cte AS (
  SELECT *, ROW_NUMBER() OVER (PARTITION BY PROJECT, SITE_ID, RUN_NO ORDER BY RMU_TO ASC) as rn
  FROM #TempDefectAggregation2
)
SELECT * 
INTO #TempDefectAggregation3
FROM (
  SELECT 
    PROJECT,
    SITE_ID,
    RUN_NO,
    DRILLER_FROM,
    DRILLER_TO,
    DRILLER_THICKNESS,
    GEO_FROM_DEPTH,
    GEO_TO_DEPTH,
    GEO_THICKNESS,
    RMU_TYPE,
    RMU_FROM,
    RMU_TO,
    DEFECT_TYPE,
    DEFECT_DEPTH,
	DEFECT_FROM,
	DEFECT_TO
  FROM cte
  UNION ALL
  SELECT 
    PROJECT,
    SITE_ID, 
    RUN_NO,
    DRILLER_FROM, 
    DRILLER_TO,
    DRILLER_THICKNESS,
    GEO_FROM_DEPTH,
    GEO_TO_DEPTH,
    GEO_THICKNESS,
    'A' AS RMU_TYPE,
    RMU_FROM AS RMU_FROM,
    RMU_TO AS RMU_TO, 
    'A' AS DEFECT_TYPE, 
    RMU_FROM AS DEFECT_DEPTH,
	DEFECT_FROM,
	DEFECT_TO
  FROM cte
  WHERE rn = 1
) foo
WHERE DEFECT_TYPE IS NOT NULL
--AND RUN_NO = 26
ORDER BY RUN_NO, DEFECT_DEPTH, DEFECT_TYPE;

SELECT 
    PROJECT,
    SITE_ID,
    RUN_NO,
    DRILLER_FROM,
    DRILLER_TO,
    DRILLER_THICKNESS,
    GEO_FROM_DEPTH,
    GEO_TO_DEPTH,
    GEO_THICKNESS,
    RMU_TYPE,
    RMU_FROM,
    RMU_TO,
    DEFECT_TYPE,
    DEFECT_DEPTH,
	CASE
		WHEN DEFECT_TYPE IN ('Z', 'A')
		THEN DEFECT_DEPTH
		ELSE DEFECT_FROM
	END AS DEFECT_FROM,
	CASE
		WHEN DEFECT_TYPE IN ('Z', 'A')
		THEN DEFECT_DEPTH
		ELSE DEFECT_TO
	END AS DEFECT_TO
INTO #TempDefectAggregation4
FROM #TempDefectAggregation3
ORDER BY RUN_NO, DEFECT_DEPTH;

WITH cte AS (
    SELECT *,
        ROW_NUMBER() OVER (PARTITION BY PROJECT, SITE_ID, RUN_NO ORDER BY DEFECT_DEPTH DESC) AS rn
    FROM #TempDefectAggregation4
)
SELECT *
INTO #TempDefectAggregation5
FROM (
    SELECT 
        PROJECT,
        SITE_ID, 
        RUN_NO,
        DRILLER_FROM, 
        DRILLER_TO,
        DRILLER_THICKNESS,
        GEO_FROM_DEPTH,
        GEO_TO_DEPTH,
        GEO_THICKNESS,
        RMU_TYPE,
        RMU_FROM,
        RMU_TO,
        DEFECT_TYPE,
        DEFECT_DEPTH,
		CASE
		    WHEN DEFECT_FROM IS NULL
			THEN DEFECT_DEPTH
			ELSE DEFECT_FROM
		END AS DEFECT_FROM,
		CASE
		    WHEN DEFECT_FROM IS NULL
			THEN DEFECT_DEPTH
			ELSE DEFECT_TO
		END AS DEFECT_TO
    FROM cte
    UNION ALL
    SELECT 
        PROJECT,
        SITE_ID, 
        RUN_NO,
        DRILLER_FROM, 
        DRILLER_TO,
        DRILLER_THICKNESS,
        GEO_FROM_DEPTH,
        GEO_TO_DEPTH,
        GEO_THICKNESS,
        RMU_TYPE,
        RMU_FROM AS RMU_FROM,
        RMU_TO AS RMU_TO,
        DEFECT_TYPE,
        RMU_FROM AS DEFECT_DEPTH,
		CASE
		    WHEN DEFECT_FROM IS NULL
			THEN DEFECT_DEPTH
			ELSE DEFECT_FROM
		END AS DEFECT_FROM,
		CASE
		    WHEN DEFECT_FROM IS NULL
			THEN DEFECT_DEPTH
			ELSE DEFECT_TO
		END AS DEFECT_TO
    FROM cte
    WHERE RMU_TYPE IN ('L', 'N', 'B', 'O', 'S')
) wrapped_cte
WHERE DEFECT_DEPTH IS NOT NULL
ORDER BY 
	RUN_NO,
	RMU_FROM,
	DEFECT_DEPTH;

WITH cte AS (
    SELECT *,
        CASE WHEN ROUND(DEFECT_FROM - LAG(DEFECT_TO) OVER (PARTITION BY PROJECT, SITE_ID, RUN_NO ORDER BY DEFECT_TO, DEFECT_TYPE), 3) < 0.01
		THEN 0
		ELSE ROUND(DEFECT_FROM - LAG(DEFECT_TO) OVER (PARTITION BY PROJECT, SITE_ID, RUN_NO ORDER BY DEFECT_TO, DEFECT_TYPE), 3)
		END AS defect_difference
    FROM #TempDefectAggregation5
), 
cte2 AS (
   SELECT *,  
       CASE 
           WHEN RMU_TYPE IN ('D', 'Z') AND defect_difference >= 0.1 THEN defect_difference
		   WHEN RMU_TYPE IN ('L', 'N', 'B', 'O', 'S') THEN 0
		   --WHEN RMU_TYPE = 'U' THEN round(RMU_TO - RMU_FROM, 2)
		   WHEN RMU_TYPE = 'U' THEN ROUND(DEFECT_TO - DEFECT_FROM, 2) + ROUND(DEFECT_FROM - LAG(DEFECT_TO) OVER (PARTITION BY PROJECT, SITE_ID, RUN_NO ORDER BY DEFECT_TO, DEFECT_TYPE), 2)
           ELSE 0 
       END AS THICKNESS
   FROM cte
)
SELECT *
INTO #TempDefectAggregation6
FROM (
    SELECT 
        PROJECT,
        SITE_ID, 
        RUN_NO,
        DRILLER_FROM, 
        DRILLER_TO,
        DRILLER_THICKNESS,
        GEO_FROM_DEPTH,
        GEO_TO_DEPTH,
        GEO_THICKNESS,
        RMU_TYPE,
        RMU_FROM,
        RMU_TO,
        DEFECT_TYPE,
        DEFECT_DEPTH,
		DEFECT_FROM,
		DEFECT_TO,
        THICKNESS
    FROM cte2 
) AS wrapped_cte2
WHERE THICKNESS IS NOT NULL
ORDER BY
PROJECT,
SITE_ID,
RUN_NO,
DEFECT_TO,
DEFECT_TYPE

SELECT 
    t.PROJECT, t.SITE_ID, t.RUN_NO, t.DRILLER_FROM, t.DRILLER_TO, t.DRILLER_THICKNESS,
    t.GEO_FROM_DEPTH, t.GEO_TO_DEPTH, t.GEO_THICKNESS,
    SUM(t.THICKNESS) as THICKNESS,
	--CAST(ROUND(SUM(THICKNESS / GEO_THICKNESS),2) AS DECIMAL (4,2)) AS RQD
	CAST(ROUND(SUM(THICKNESS / DRILLER_THICKNESS),2) AS DECIMAL (5,2)) AS RQD,
	s.DATE_INSERTED
--INTO #TempDefectAggregation7
FROM 
    #TempDefectAggregation6 t
LEFT JOIN
	GB_SITE s ON s.PROJECT = t.PROJECT AND s.SITE_ID = t.SITE_ID
GROUP BY 
    t.PROJECT, t.SITE_ID, t.RUN_NO, t.DRILLER_FROM, t.DRILLER_TO,
    t.DRILLER_THICKNESS, t.GEO_FROM_DEPTH, t.GEO_TO_DEPTH,
    t.GEO_THICKNESS, s.DATE_INSERTED
ORDER BY 
    PROJECT,
	DATE_INSERTED,
	SITE_ID,
    RUN_NO;

--UPDATE d
--SET RQD = t.RQD
--FROM GB_CS_DRILLING d
--JOIN #TempDefectAggregation7 t 
--ON t.PROJECT = d.PROJECT AND t.SITE_ID = d.SITE_ID AND t.RUN_NO = d.RUN_NO;
